import {test, assert, describe} from 'vitest';
import type {PackageJson} from '@fuzdev/fuz_util/package_json.js';
import type {SourceJson} from '@fuzdev/fuz_util/source_json.js';

import {library_generate_output} from '$lib/library_output.js';

describe('library_generate_output', () => {
	// Helper to create valid package_json for tests (library_json_parse requires repository)
	const create_test_package_json = (overrides: Partial<PackageJson> = {}): PackageJson => ({
		name: '@test/package',
		version: '1.0.0',
		repository: 'https://github.com/test/package',
		...overrides,
	});

	test('generates JSON and .ts wrapper files', () => {
		const package_json = create_test_package_json({type: 'module'});

		const source_json: SourceJson = {
			name: '@test/package',
			version: '1.0.0',
			modules: [
				{
					path: 'test.ts',
					declarations: [{name: 'foo', kind: 'function'}],
				},
			],
		};

		const result = library_generate_output(package_json, source_json);

		// Check we get both outputs
		assert.ok(result.json_content);
		assert.ok(result.ts_content);

		// Check JSON is valid
		const parsed = JSON.parse(result.json_content);
		assert.ok(parsed.package_json);
		assert.ok(parsed.source_json);

		// Check .ts wrapper has correct structure
		assert.ok(result.ts_content.includes('// generated by library.gen.ts - do not edit'));
		assert.ok(result.ts_content.includes("import json from './library.json'"));
		assert.ok(result.ts_content.includes('export const library_json'));
	});

	test('properly serializes library_json data in JSON', () => {
		const package_json = create_test_package_json({
			name: '@scope/pkg',
			version: '2.0.0',
			type: 'module',
			description: 'Test package',
		});

		const source_json: SourceJson = {
			name: '@scope/pkg',
			version: '2.0.0',
		};

		const result = library_generate_output(package_json, source_json);
		const parsed = JSON.parse(result.json_content);

		// Verify library_json contains parsed data
		assert.strictEqual(parsed.package_json.name, '@scope/pkg');
		assert.strictEqual(parsed.package_json.version, '2.0.0');
		// library_json includes computed fields like repo_name
		assert.ok(parsed.repo_name);
	});

	test('properly serializes source_json with modules', () => {
		const package_json = create_test_package_json();

		const source_json: SourceJson = {
			name: '@test/package',
			version: '1.0.0',
			modules: [
				{
					path: 'foo.ts',
					declarations: [
						{name: 'foo', kind: 'function'},
						{name: 'Bar', kind: 'type'},
					],
				},
			],
		};

		const result = library_generate_output(package_json, source_json);
		const parsed = JSON.parse(result.json_content);

		// Verify source_json is included
		assert.ok(parsed.source_json);
		assert.ok(parsed.source_json.modules);
		assert.strictEqual(parsed.source_json.modules[0].path, 'foo.ts');
		assert.strictEqual(parsed.source_json.modules[0].declarations[0].name, 'foo');
		assert.strictEqual(parsed.source_json.modules[0].declarations[0].kind, 'function');
	});

	test('uses tab indentation in JSON', () => {
		const package_json = create_test_package_json();

		const source_json: SourceJson = {
			name: '@test/package',
			version: '1.0.0',
		};

		const result = library_generate_output(package_json, source_json);

		// Should use tabs for indentation
		assert.ok(result.json_content.includes('\t"package_json"'), 'Expected tab-indented JSON');
	});

	test('handles empty modules array', () => {
		const package_json = create_test_package_json();

		const source_json: SourceJson = {
			name: '@test/package',
			version: '1.0.0',
			modules: [],
		};

		const result = library_generate_output(package_json, source_json);
		const parsed = JSON.parse(result.json_content);

		assert.deepStrictEqual(parsed.source_json.modules, []);
	});

	test('handles undefined modules', () => {
		const package_json = create_test_package_json();

		const source_json: SourceJson = {
			name: '@test/package',
			version: '1.0.0',
		};

		const result = library_generate_output(package_json, source_json);
		const parsed = JSON.parse(result.json_content);

		assert.ok(parsed.package_json);
		assert.ok(parsed.source_json);
	});
});
